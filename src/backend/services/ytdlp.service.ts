/**
 * yt-dlp Service
 * Command-line wrapper for yt-dlp operations
 */

import { spawn, exec } from 'child_process';
import { promisify } from 'util';
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { configService } from './config.service';

const execAsync = promisify(exec);

export interface YtdlpVideoInfo {
  id: string;
  title: string;
  description?: string;
  duration: number;
  uploader?: string;
  upload_date?: string;
  thumbnail?: string;
  language?: string;
  available_subtitles: Record<string, any[]>;
}

export interface YtdlpDownloadProgress {
  total_bytes?: number;
  downloaded_bytes?: number;
  speed?: number;
  eta?: number;
  status: string;
  filename?: string;
}

export interface YtdlpSubtitleInfo {
  language: string;
  language_name: string;
  is_auto_generated: boolean;
  format: 'json3';
  url?: string;
}

export class YtdlpService extends EventEmitter {
  private readonly ytdlpPath: string;
  private readonly timeout: number;
  private readonly retryCount: number;

  constructor() {
    super();
    this.ytdlpPath = configService.getYtdlpConfig().executablePath;
    this.timeout = configService.getYtdlpConfig().timeout;
    this.retryCount = configService.getYtdlpConfig().retryCount;
  }

  /**
   * Check if yt-dlp is available and working
   */
  async isAvailable(): Promise<boolean> {
    try {
      const { stdout } = await execAsync(`"${this.ytdlpPath}" --version`);
      const version = stdout.trim();
      logger.info('yt-dlp is available', { version });
      return true;
    } catch (error) {
      logger.error('yt-dlp not available', error);
      return false;
    }
  }

  /**
   * Get yt-dlp version
   */
  async getVersion(): Promise<string> {
    try {
      const { stdout } = await execAsync(`"${this.ytdlpPath}" --version`);
      return stdout.trim();
    } catch (error) {
      logger.error('Failed to get yt-dlp version', error);
      throw new Error('yt-dlp not available');
    }
  }

  /**
   * Extract video information from YouTube URL
   * @param url YouTube video URL
   * @returns Promise<YtdlpVideoInfo> - Video information
   */
  async getVideoInfo(url: string): Promise<YtdlpVideoInfo> {
    logger.info('Getting video info', { url });

    // Build command - quote the URL to handle special characters
    const escapedUrl = url.replace(/'/g, "'\\''");
    const command = `${this.ytdlpPath} --dump-json --no-download '${escapedUrl}'`;

    try {
      const { stdout, stderr } = await this.execWithRetry(command);

      if (stderr && stderr.includes('ERROR')) {
        throw new Error(`yt-dlp error: ${stderr}`);
      }

      const videoInfo = JSON.parse(stdout);

      // Transform to our internal format
      const transformedInfo: YtdlpVideoInfo = {
        id: videoInfo.id,
        title: videoInfo.title,
        description: videoInfo.description,
        duration: videoInfo.duration || 0,
        uploader: videoInfo.uploader,
        upload_date: videoInfo.upload_date,
        thumbnail: videoInfo.thumbnail,
        language: this.extractLanguage(videoInfo),
        available_subtitles: this.transformSubtitles(videoInfo.subtitles || {}, videoInfo.automatic_captions || {})
      };

      logger.info('Video info retrieved successfully', {
        videoId: transformedInfo.id,
        title: transformedInfo.title,
        duration: transformedInfo.duration,
        subtitlesCount: Object.keys(transformedInfo.available_subtitles).length
      });

      return transformedInfo;
    } catch (error) {
      logger.error('Failed to get video info', { url, error });
      throw this.handleYtdlpError(error as Error, url);
    }
  }

  /**
   * Download subtitles for a video
   * @param url YouTube video URL
   * @param outputTemplate Output file template
   * @param languages Preferred languages (optional)
   * @param includeAutoGenerated Include auto-generated subtitles (optional)
   * @returns Promise<void>
   */
  async downloadSubtitles(
    url: string,
    outputTemplate: string,
    languages?: string[],
    includeAutoGenerated: boolean = true
  ): Promise<void> {
    logger.info('Downloading subtitles', {
      url,
      outputTemplate,
      languages,
      includeAutoGenerated
    });

    const args = [
      '--write-subs',
      '--write-auto-subs',
      '--sub-format', 'json3',
      '--skip-download',
      '-o', outputTemplate
    ];

    if (languages && languages.length > 0) {
      args.push('--sub-langs', languages.join(','));
    }

    if (!includeAutoGenerated) {
      // Note: yt-dlp doesn't have a direct flag to exclude auto-generated subs
      // We'll filter them out later
    }

    args.push(url);

    // Build command - quote each argument individually to avoid shell interpretation
    const quotedArgs = args.map(arg => {
      // Escape any single quotes in the argument
      const escaped = arg.replace(/'/g, "'\\''");
      return `'${escaped}'`;
    });
    const command = `${this.ytdlpPath} ${quotedArgs.join(' ')}`;

    try {
      const { stdout, stderr } = await this.execWithRetry(command);

      if (stderr && stderr.includes('ERROR')) {
        throw new Error(`yt-dlp error: ${stderr}`);
      }

      logger.info('Subtitles downloaded successfully', { url });
    } catch (error) {
      logger.error('Failed to download subtitles', { url, error });
      throw this.handleYtdlpError(error as Error, url);
    }
  }

  /**
   * Download video thumbnail
   * @param url YouTube video URL
   * @param outputPath Output file path
   * @returns Promise<string> - Path to downloaded thumbnail
   */
  async downloadThumbnail(url: string, outputPath: string): Promise<string> {
    logger.info('Downloading thumbnail', { url, outputPath });

    // Build command - quote arguments to handle special characters
    const args = [
      '--write-thumbnail',
      '--skip-download',
      '-o', outputPath,
      url
    ];

    const quotedArgs = args.map(arg => {
      const escaped = arg.replace(/'/g, "'\\''");
      return `'${escaped}'`;
    });
    const command = `${this.ytdlpPath} ${quotedArgs.join(' ')}`;

    try {
      const { stdout, stderr } = await this.execWithRetry(command);

      if (stderr && stderr.includes('ERROR')) {
        throw new Error(`yt-dlp error: ${stderr}`);
      }

      logger.info('Thumbnail downloaded successfully', { url, outputPath });
      return outputPath;
    } catch (error) {
      logger.error('Failed to download thumbnail', { url, error });
      throw this.handleYtdlpError(error as Error, url);
    }
  }

  /**
   * Execute command with retry logic
   */
  private async execWithRetry(command: string): Promise<{ stdout: string; stderr: string }> {
    let lastError: Error;

    for (let attempt = 1; attempt <= this.retryCount; attempt++) {
      try {
        logger.debug(`Executing yt-dlp command (attempt ${attempt})`, { command });

        return await new Promise((resolve, reject) => {
          const child = exec(command, { timeout: this.timeout * 1000 }, (error, stdout, stderr) => {
            if (error) {
              reject(error);
            } else {
              resolve({ stdout, stderr });
            }
          });

          // Forward stderr to logger for debugging
          if (child.stderr) {
            child.stderr.on('data', (data) => {
              const message = data.toString().trim();
              if (message && !message.startsWith('[debug]')) {
                logger.debug('yt-dlp stderr', { message });
              }
            });
          }
        });
      } catch (error) {
        lastError = error as Error;
        logger.warn(`yt-dlp command failed (attempt ${attempt})`, {
          command,
          error: lastError.message
        });

        if (attempt < this.retryCount) {
          // Wait before retry (exponential backoff)
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError!;
  }

  /**
   * Transform yt-dlp subtitle format to our internal format
   */
  private transformSubtitles(subtitles: Record<string, any[]>, autoSubtitles: Record<string, any[]>): Record<string, any[]> {
    const result: Record<string, any[]> = {};

    // Add manual subtitles
    for (const [lang, formats] of Object.entries(subtitles)) {
      result[lang] = formats.map(format => ({
        ...format,
        is_auto_generated: false
      }));
    }

    // Add auto-generated subtitles (only if we don't have manual ones for the same language)
    for (const [lang, formats] of Object.entries(autoSubtitles)) {
      if (!result[lang]) {
        result[lang] = formats.map(format => ({
          ...format,
          is_auto_generated: true
        }));
      }
    }

    return result;
  }

  /**
   * Extract language from video info
   */
  private extractLanguage(videoInfo: any): string | undefined {
    if (videoInfo.language) {
      return videoInfo.language;
    }

    // Try to infer from available subtitles
    const subtitles = { ...videoInfo.subtitles, ...videoInfo.automatic_captions };
    const languages = Object.keys(subtitles);

    if (languages.length > 0) {
      return languages[0];
    }

    return undefined;
  }

  /**
   * Handle yt-dlp specific errors and convert to appropriate error types
   */
  private handleYtdlpError(error: Error, url: string): Error {
    const errorMessage = error.message.toLowerCase();

    if (errorMessage.includes('video unavailable') || errorMessage.includes('not found')) {
      return new Error(`Video not found or unavailable: ${url}`);
    }

    if (errorMessage.includes('subtitles') && errorMessage.includes('not available')) {
      return new Error(`No subtitles available for this video: ${url}`);
    }

    if (errorMessage.includes('network') || errorMessage.includes('connection')) {
      return new Error(`Network error while accessing video: ${url}`);
    }

    if (errorMessage.includes('timeout')) {
      return new Error(`Timeout while processing video: ${url}`);
    }

    if (errorMessage.includes('rate limit') || errorMessage.includes('too many requests')) {
      return new Error(`Rate limited. Please try again later: ${url}`);
    }

    return new Error(`yt-dlp error: ${error.message}`);
  }
}