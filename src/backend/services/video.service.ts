/**
 * Video Service
 * Handles YouTube video information retrieval
 */

import { YouTubeVideo, SubtitleInfo } from '../../shared/types/video.types';
import { logger } from '../utils/logger';
import { YtdlpService, YtdlpVideoInfo } from './ytdlp.service';

export class VideoService {
  private ytdlpService: YtdlpService;

  constructor() {
    this.ytdlpService = new YtdlpService();
  }

  /**
   * Get YouTube video information
   * @param url - YouTube video URL
   * @returns Promise<YouTubeVideo> - Video information
   */
  async getVideoInfo(url: string): Promise<YouTubeVideo> {
    logger.info('Getting video info from YouTube URL', { url });

    try {
      // Check if yt-dlp is available
      const isAvailable = await this.ytdlpService.isAvailable();
      if (!isAvailable) {
        throw new Error('yt-dlp is not available. Please ensure it is installed and accessible.');
      }

      // Get video information from yt-dlp
      const ytdlpInfo = await this.ytdlpService.getVideoInfo(url);

      // Transform yt-dlp info to our internal format
      const videoInfo: YouTubeVideo = {
        id: ytdlpInfo.id,
        url,
        title: ytdlpInfo.title,
        description: ytdlpInfo.description,
        duration: ytdlpInfo.duration,
        uploader: ytdlpInfo.uploader,
        uploadDate: ytdlpInfo.upload_date ? new Date(ytdlpInfo.upload_date) : undefined,
        thumbnailUrl: ytdlpInfo.thumbnail,
        language: ytdlpInfo.language,
        availableSubtitles: this.transformSubtitleInfos(ytdlpInfo.available_subtitles),
        createdAt: new Date()
      };

      logger.info('Video info retrieved successfully', {
        videoId: videoInfo.id,
        title: videoInfo.title,
        duration: videoInfo.duration,
        subtitlesCount: videoInfo.availableSubtitles.length
      });

      return videoInfo;
    } catch (error) {
      logger.error('Failed to get video info', { url, error });
      throw error;
    }
  }

  /**
   * Transform yt-dlp subtitle format to our internal format
   * @param subtitles - yt-dlp subtitle information
   * @returns SubtitleInfo[] - Array of subtitle information
   */
  private transformSubtitleInfos(subtitles: Record<string, any[]>): SubtitleInfo[] {
    const subtitleInfos: SubtitleInfo[] = [];

    for (const [language, formats] of Object.entries(subtitles)) {
      // Check if json3 format is available
      const json3Format = formats.find(format => format.ext === 'json3');
      if (json3Format) {
        subtitleInfos.push({
          language,
          languageName: this.getLanguageName(language),
          isAutoGenerated: json3Format.is_auto_generated || false,
          format: 'json3',
          url: json3Format.url
        });
      }
    }

    return subtitleInfos.sort((a, b) => {
      // Sort by manual subtitles first, then by language
      if (a.isAutoGenerated !== b.isAutoGenerated) {
        return a.isAutoGenerated ? 1 : -1;
      }
      return a.language.localeCompare(b.language);
    });
  }

  /**
   * Get human-readable language name from language code
   * @param languageCode - Language code (e.g., 'en', 'zh')
   * @returns string - Language name (e.g., 'English', 'Chinese')
   */
  private getLanguageName(languageCode: string): string {
    const languageNames: Record<string, string> = {
      'en': 'English',
      'zh': 'Chinese',
      'zh-CN': 'Chinese (Simplified)',
      'zh-TW': 'Chinese (Traditional)',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ar': 'Arabic',
      'hi': 'Hindi',
      'th': 'Thai',
      'vi': 'Vietnamese',
      'tr': 'Turkish',
      'pl': 'Polish',
      'nl': 'Dutch',
      'sv': 'Swedish',
      'da': 'Danish',
      'no': 'Norwegian',
      'fi': 'Finnish'
    };

    return languageNames[languageCode] || languageCode.toUpperCase();
  }

  /**
   * Check if yt-dlp is available and configured correctly
   * @returns Promise<boolean> - Whether yt-dlp is available
   */
  async isYtdlpAvailable(): Promise<boolean> {
    return this.ytdlpService.isAvailable();
  }

  /**
   * Get yt-dlp version
   * @returns Promise<string> - yt-dlp version
   */
  async getYtdlpVersion(): Promise<string> {
    return this.ytdlpService.getVersion();
  }
}