/**
 * Subtitle Service
 * Handles subtitle download and processing
 */

import {
  DownloadRequest,
  DownloadResult,
  ProcessingRequest,
  ProcessedText,
  YouTubeVideo,
  SubtitleData,
  JSON3Content
} from '../../shared/types/video.types';
import { logger } from '../utils/logger';
import { YtdlpService } from './ytdlp.service';
import { VideoService } from './video.service';
import { storageService } from './storage.service';
import { configService } from './config.service';
import { PythonService } from './python.service';
import { readFile } from 'fs/promises';
import { join } from 'path';

export class SubtitleService {
  private ytdlpService: YtdlpService;
  private videoService: VideoService;
  private pythonService: PythonService;

  constructor() {
    this.ytdlpService = new YtdlpService();
    this.videoService = new VideoService();
    this.pythonService = new PythonService();
  }

  /**
   * Download subtitles for a YouTube video
   * @param request - Download request parameters
   * @returns Promise<DownloadResult> - Download result
   */
  async downloadSubtitles(request: DownloadRequest): Promise<DownloadResult> {
    const startTime = Date.now();
    logger.info('Starting subtitle download', {
      videoUrl: request.videoUrl,
      preferredLanguage: request.preferredLanguage,
      includeAutoGenerated: request.includeAutoGenerated
    });

    try {
      // Check if yt-dlp is available
      const isAvailable = await this.ytdlpService.isAvailable();
      if (!isAvailable) {
        throw new Error('yt-dlp is not available. Please ensure it is installed and accessible.');
      }

      // Get video information first
      const videoInfo = await this.videoService.getVideoInfo(request.videoUrl);

      // Create video-specific download directory
      const videoDir = join(configService.getStorageConfig().basePath,
                          configService.getStorageConfig().downloadsDir,
                          videoInfo.id);

      await storageService.ensureDirectory(videoDir);

      // Filter available subtitles based on request
      const availableSubtitles = this.filterSubtitles(
        videoInfo.availableSubtitles,
        request.preferredLanguage,
        request.includeAutoGenerated
      );

      if (availableSubtitles.length === 0) {
        throw new Error('No subtitles available matching the specified criteria');
      }

      // Download subtitles
      const outputTemplate = join(videoDir, '%(title)s.%(ext)s');
      const languages = availableSubtitles.map(s => s.language);

      await this.ytdlpService.downloadSubtitles(
        request.videoUrl,
        outputTemplate,
        languages,
        request.includeAutoGenerated
      );

      // Process downloaded subtitle files
      const subtitleDatas: SubtitleData[] = [];
      for (const subtitleInfo of availableSubtitles) {
        const subtitleData = await this.processDownloadedSubtitle(
          videoInfo.id,
          subtitleInfo.language,
          videoDir,
          subtitleInfo.isAutoGenerated
        );
        if (subtitleData) {
          subtitleDatas.push(subtitleData);
        }
      }

      const downloadDuration = Date.now() - startTime;

      const result: DownloadResult = {
        success: true,
        video: videoInfo,
        subtitles: subtitleDatas,
        downloadDuration
      };

      logger.info('Subtitle download completed successfully', {
        videoId: videoInfo.id,
        subtitlesCount: subtitleDatas.length,
        duration: downloadDuration
      });

      return result;
    } catch (error) {
      const downloadDuration = Date.now() - startTime;
      logger.error('Subtitle download failed', {
        videoUrl: request.videoUrl,
        error,
        duration: downloadDuration
      });

      return {
        success: false,
        video: {} as YouTubeVideo,
        subtitles: [],
        errors: [error instanceof Error ? error.message : 'Unknown error occurred'],
        downloadDuration
      };
    }
  }

  /**
   * Process downloaded subtitles into clean text
   * @param request - Processing request parameters
   * @returns Promise<ProcessedText> - Processed text result
   */
  async processSubtitles(request: ProcessingRequest): Promise<ProcessedText> {
    const startTime = Date.now();
    logger.info('Processing subtitles', {
      subtitleFile: request.subtitleFile,
      outputPath: request.outputPath
    });

    try {
      // Check if Python service is available
      const pythonAvailable = await this.pythonService.isAvailable();

      let cleanText: string;
      let wordCount: number;
      let processingDuration: number;
      let outputPath: string;

      if (pythonAvailable) {
        logger.info('Using Python script for subtitle processing');

        // Use Python script for processing
        outputPath = request.outputPath || this.generateOutputPath(request.subtitleFile);

        const pythonResult = await this.pythonService.processSubtitles(
          request.subtitleFile,
          outputPath,
          {
            removeTimestamps: request.removeTimestamps,
            mergeDuplicates: request.mergeDuplicates,
            formatParagraphs: request.formatParagraphs,
            minSegmentLength: configService.getProcessingConfig().defaultOptions.minSegmentLength,
            languageCode: this.extractLanguageFromPath(request.subtitleFile)
          }
        );

        if (!pythonResult.success) {
          throw new Error(`Python processing failed: ${pythonResult.error}`);
        }

        // Read the processed text from Python output
        cleanText = await readFile(outputPath, 'utf-8');
        wordCount = pythonResult.stats.totalWords;
        processingDuration = pythonResult.stats.processingTime * 1000; // Convert to milliseconds

        logger.info('Python processing completed successfully', {
          inputFile: pythonResult.inputFile,
          outputFile: pythonResult.outputFile,
          stats: pythonResult.stats
        });
      } else {
        logger.warn('Python service not available, falling back to built-in processing');

        // Fall back to built-in processing
        const subtitleContent = await readFile(request.subtitleFile, 'utf-8');
        const jsonData: JSON3Content = JSON.parse(subtitleContent);

        // Extract and clean text content
        cleanText = this.extractCleanText(jsonData, {
          removeTimestamps: request.removeTimestamps,
          mergeDuplicates: request.mergeDuplicates,
          formatParagraphs: request.formatParagraphs
        });

        // Determine output file path
        outputPath = request.outputPath || this.generateOutputPath(request.subtitleFile);

        // Write processed text to file
        await storageService.writeFile(outputPath, cleanText);

        wordCount = this.countWords(cleanText);
        processingDuration = Date.now() - startTime;

        logger.info('Built-in processing completed successfully', {
          inputFile: request.subtitleFile,
          outputFile: outputPath,
          wordCount,
          duration: processingDuration
        });
      }

      // Get file stats for verification
      const fileStats = await storageService.getFileStats(outputPath);

      // Extract video ID from file path
      const videoId = this.extractVideoIdFromPath(request.subtitleFile);

      const result: ProcessedText = {
        videoId,
        sourceLanguage: this.extractLanguageFromPath(request.subtitleFile),
        content: cleanText,
        wordCount,
        processedAt: new Date(),
        sourceFile: request.subtitleFile,
        outputFile: outputPath,
        processingDuration
      };

      logger.info('Subtitle processing completed successfully', {
        videoId: result.videoId,
        wordCount: result.wordCount,
        duration: processingDuration,
        fileSize: fileStats.size,
        usedPython: pythonAvailable
      });

      return result;
    } catch (error) {
      const processingDuration = Date.now() - startTime;
      logger.error('Subtitle processing failed', {
        subtitleFile: request.subtitleFile,
        error,
        duration: processingDuration
      });
      throw error;
    }
  }

  /**
   * Filter subtitles based on request criteria
   */
  private filterSubtitles(
    subtitles: any[],
    preferredLanguage?: string,
    includeAutoGenerated: boolean = true
  ): any[] {
    let filtered = subtitles;

    // Filter by language if specified
    if (preferredLanguage) {
      filtered = filtered.filter(s => s.language === preferredLanguage);
    }

    // Filter out auto-generated if not requested
    if (!includeAutoGenerated) {
      filtered = filtered.filter(s => !s.isAutoGenerated);
    }

    return filtered;
  }

  /**
   * Process downloaded subtitle file into SubtitleData
   */
  private async processDownloadedSubtitle(
    videoId: string,
    language: string,
    videoDir: string,
    isAutoGenerated: boolean
  ): Promise<SubtitleData | null> {
    try {
      // Find the subtitle file (yt-dlp creates various naming patterns)
      const files = await storageService.listFiles(videoDir);
      const subtitleFile = files.find(file =>
        file.endsWith('.json3') &&
        (file.includes(language) || file.includes(`${language}.json3`))
      );

      if (!subtitleFile) {
        logger.warn('Subtitle file not found', { videoId, language });
        return null;
      }

      // subtitleFile from listFiles already includes the full path
      const filePath = subtitleFile;
      const fileContent = await readFile(filePath, 'utf-8');
      const jsonData: JSON3Content = JSON.parse(fileContent);

      const fileStats = await storageService.getFileStats(filePath);

      return {
        videoId,
        language,
        format: 'json3',
        isAutoGenerated,
        content: jsonData,
        filePath,
        downloadedAt: new Date(),
        fileSize: fileStats.size
      };
    } catch (error) {
      logger.error('Failed to process downloaded subtitle', { videoId, language, error });
      return null;
    }
  }

  /**
   * Extract clean text from JSON3 content
   */
  private extractCleanText(
    jsonData: JSON3Content,
    options: {
      removeTimestamps: boolean;
      mergeDuplicates: boolean;
      formatParagraphs: boolean;
    }
  ): string {
    let segments: string[] = [];

    // Extract text from all segments
    for (const event of jsonData.events) {
      for (const seg of event.segs) {
        if (seg.utf8.trim()) {
          segments.push(seg.utf8.trim());
        }
      }
    }

    // Remove duplicates if requested
    if (options.mergeDuplicates) {
      segments = this.removeDuplicateSegments(segments);
    }

    // Format paragraphs if requested
    if (options.formatParagraphs) {
      segments = this.formatIntoParagraphs(segments);
    }

    return segments.join('\n');
  }

  /**
   * Remove duplicate segments
   */
  private removeDuplicateSegments(segments: string[]): string[] {
    const seen = new Set<string>();
    const result: string[] = [];

    for (const segment of segments) {
      const normalized = segment.toLowerCase().trim();
      if (!seen.has(normalized) && normalized.length > 5) { // Filter very short segments
        seen.add(normalized);
        result.push(segment);
      }
    }

    return result;
  }

  /**
   * Format segments into paragraphs
   */
  private formatIntoParagraphs(segments: string[]): string[] {
    const paragraphs: string[] = [];
    let currentParagraph: string[] = [];

    for (const segment of segments) {
      currentParagraph.push(segment);

      // Start new paragraph after sentence-ending punctuation
      if (segment.match(/[.!?]$/)) {
        paragraphs.push(currentParagraph.join(' '));
        currentParagraph = [];
      }
    }

    // Add any remaining text
    if (currentParagraph.length > 0) {
      paragraphs.push(currentParagraph.join(' '));
    }

    return paragraphs;
  }

  /**
   * Count words in text
   */
  private countWords(text: string): number {
    return text.trim().split(/\s+/).filter(word => word.length > 0).length;
  }

  /**
   * Generate output file path
   */
  private generateOutputPath(inputPath: string): string {
    const dir = inputPath.substring(0, inputPath.lastIndexOf('/'));
    const filename = inputPath.substring(inputPath.lastIndexOf('/') + 1);
    const baseName = filename.replace('.json3', '');
    return join(dir, `${baseName}.txt`);
  }

  /**
   * Extract video ID from file path
   */
  private extractVideoIdFromPath(filePath: string): string {
    const parts = filePath.split('/');
    const downloadsIndex = parts.findIndex(part => part === 'downloads');

    if (downloadsIndex !== -1 && downloadsIndex + 1 < parts.length) {
      return parts[downloadsIndex + 1];
    }

    return 'unknown';
  }

  /**
   * Extract language from file path
   */
  private extractLanguageFromPath(filePath: string): string {
    const filename = filePath.substring(filePath.lastIndexOf('/') + 1);
    const match = filename.match(/^([a-z]{2,3}(-[A-Z]{2})?)/i);

    if (match) {
      return match[1];
    }

    return 'unknown';
  }
}