/**
 * Validation Middleware
 * Request parameter validation functions
 */

import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';

/**
 * YouTube URL validation regex
 */
const YOUTUBE_URL_REGEX = /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)[a-zA-Z0-9_-]{11}(&.*)?$/;

/**
 * File ID validation regex (alphanumeric and basic symbols)
 */
const FILE_ID_REGEX = /^[a-zA-Z0-9._-]+$/;

/**
 * Validate video info request parameters
 */
export function validateVideoInfoRequest(req: Request, res: Response, next: NextFunction): void {
  const { url } = req.query;

  if (!url) {
    logger.warn('Missing URL parameter in video info request', {
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'MISSING_URL',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'URL parameter is required',
        timestamp: new Date()
      }
    });
    return;
  }

  if (typeof url !== 'string') {
    logger.warn('Invalid URL parameter type in video info request', {
      urlType: typeof url,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_URL_TYPE',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'URL parameter must be a string',
        timestamp: new Date()
      }
    });
    return;
  }

  if (!YOUTUBE_URL_REGEX.test(url)) {
    logger.warn('Invalid YouTube URL format in video info request', {
      url: url.substring(0, 100), // Log only first 100 chars for security
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_YOUTUBE_URL',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'Invalid YouTube URL format',
        timestamp: new Date()
      }
    });
    return;
  }

  logger.debug('Video info request validation passed', { url: url.substring(0, 100) });
  next();
}

/**
 * Validate subtitle download request body
 */
export function validateDownloadRequest(req: Request, res: Response, next: NextFunction): void {
  const { videoUrl, preferredLanguage, includeAutoGenerated } = req.body;

  if (!videoUrl || typeof videoUrl !== 'string') {
    logger.warn('Missing or invalid videoUrl in download request', {
      videoUrl,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'MISSING_VIDEO_URL',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'videoUrl is required and must be a string',
        timestamp: new Date()
      }
    });
    return;
  }

  if (!YOUTUBE_URL_REGEX.test(videoUrl)) {
    logger.warn('Invalid YouTube URL format in download request', {
      videoUrl: videoUrl.substring(0, 100),
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_YOUTUBE_URL',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'Invalid YouTube URL format',
        timestamp: new Date()
      }
    });
    return;
  }

  if (preferredLanguage && typeof preferredLanguage !== 'string') {
    logger.warn('Invalid preferredLanguage in download request', {
      preferredLanguage,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_PREFERRED_LANGUAGE',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'preferredLanguage must be a string',
        timestamp: new Date()
      }
    });
    return;
  }

  if (includeAutoGenerated !== undefined && typeof includeAutoGenerated !== 'boolean') {
    logger.warn('Invalid includeAutoGenerated in download request', {
      includeAutoGenerated,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_INCLUDE_AUTO_GENERATED',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'includeAutoGenerated must be a boolean',
        timestamp: new Date()
      }
    });
    return;
  }

  logger.debug('Download request validation passed', {
    videoUrl: videoUrl.substring(0, 100),
    preferredLanguage
  });
  next();
}

/**
 * Validate subtitle processing request body
 */
export function validateProcessingRequest(req: Request, res: Response, next: NextFunction): void {
  const { subtitleFile, outputPath, removeTimestamps, mergeDuplicates, formatParagraphs } = req.body;

  if (!subtitleFile || typeof subtitleFile !== 'string') {
    logger.warn('Missing or invalid subtitleFile in processing request', {
      subtitleFile,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'MISSING_SUBTITLE_FILE',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'subtitleFile is required and must be a string',
        timestamp: new Date()
      }
    });
    return;
  }

  // Basic file path security check
  if (subtitleFile.includes('..') || subtitleFile.includes('~')) {
    logger.warn('Potentially dangerous file path in processing request', {
      subtitleFile,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'UNSAFE_FILE_PATH',
        category: 'VALIDATION_ERROR',
        severity: 'HIGH',
        message: 'Unsafe file path detected',
        timestamp: new Date()
      }
    });
    return;
  }

  if (outputPath && typeof outputPath !== 'string') {
    logger.warn('Invalid outputPath in processing request', {
      outputPath,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_OUTPUT_PATH',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'outputPath must be a string',
        timestamp: new Date()
      }
    });
    return;
  }

  if (removeTimestamps !== undefined && typeof removeTimestamps !== 'boolean') {
    logger.warn('Invalid removeTimestamps in processing request', {
      removeTimestamps,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_REMOVE_TIMESTAMPS',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'removeTimestamps must be a boolean',
        timestamp: new Date()
      }
    });
    return;
  }

  if (mergeDuplicates !== undefined && typeof mergeDuplicates !== 'boolean') {
    logger.warn('Invalid mergeDuplicates in processing request', {
      mergeDuplicates,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_MERGE_DUPLICATES',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'mergeDuplicates must be a boolean',
        timestamp: new Date()
      }
    });
    return;
  }

  if (formatParagraphs !== undefined && typeof formatParagraphs !== 'boolean') {
    logger.warn('Invalid formatParagraphs in processing request', {
      formatParagraphs,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_FORMAT_PARAGRAPHS',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'formatParagraphs must be a boolean',
        timestamp: new Date()
      }
    });
    return;
  }

  logger.debug('Processing request validation passed', {
    subtitleFile,
    outputPath
  });
  next();
}

/**
 * Validate file ID parameter
 */
export function validateFileId(req: Request, res: Response, next: NextFunction): void {
  const { fileId } = req.params;

  if (!fileId || typeof fileId !== 'string') {
    logger.warn('Missing or invalid fileId in file request', {
      fileId,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'MISSING_FILE_ID',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'fileId is required and must be a string',
        timestamp: new Date()
      }
    });
    return;
  }

  if (!FILE_ID_REGEX.test(fileId)) {
    logger.warn('Invalid fileId format in file request', {
      fileId,
      ip: req.ip
    });

    res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_FILE_ID',
        category: 'VALIDATION_ERROR',
        severity: 'MEDIUM',
        message: 'Invalid fileId format',
        timestamp: new Date()
      }
    });
    return;
  }

  logger.debug('File ID validation passed', { fileId });
  next();
}