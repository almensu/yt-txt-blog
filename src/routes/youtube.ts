/**
 * YouTube API Routes - P02: YouTube Integration
 *
 * Provides endpoints for:
 * - Downloading YouTube subtitles (using existing ytdlpService)
 * - Processing subtitles with automatic asset import
 * - Listing processed videos
 */

import { Router, Request, Response } from 'express';
import { promises as fs } from 'fs';
import path from 'path';
import { importService } from '../services/importService.js';
import type {
  YouTubeDownloadRequest,
  YouTubeDownloadResponse,
  YouTubeProcessRequest,
  ProcessWithImportResponse,
} from '../types/index.js';

// Old system API URL
const OLD_SYSTEM_API = process.env.OLD_SYSTEM_API || 'http://localhost:8000/api';

/**
 * Helper function to find the actual subtitle file in the video directory
 * The downloaded file includes the video title, so we need to search for it
 */
async function findSubtitleFile(videoId: string, language: string): Promise<string | null> {
  const videoDir = path.join(process.cwd(), 'storage', 'downloads', videoId);

  try {
    const files = await fs.readdir(videoDir);
    // Find files matching the language (e.g., *.en.json3)
    const matchingFiles = files.filter(file =>
      file.endsWith('.json3') && file.includes(`.${language}`)
    );

    if (matchingFiles.length === 0) {
      return null;
    }

    // Return the full path of the first matching file
    return path.join(videoDir, matchingFiles[0]);
  } catch (error) {
    // Directory doesn't exist or can't be read
    return null;
  }
}

/**
 * Get video title from metadata file or fetch using yt-dlp
 * Tries to read from .info.json file first, falls back to yt-dlp
 */
async function getVideoTitle(videoId: string): Promise<string> {
  const videoDir = path.join(process.cwd(), 'storage', 'downloads', videoId);
  const infoJsonPath = path.join(videoDir, `${videoId}.info.json`);

  try {
    // First try to read from .info.json file created by yt-dlp
    const infoJson = await fs.readFile(infoJsonPath, 'utf-8');
    const info = JSON.parse(infoJson);
    return info.title || `YouTube Video ${videoId}`;
  } catch (error) {
    // If .info.json doesn't exist, use yt-dlp to get title
    try {
      const { exec } = await import('child_process');
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const cmd = `yt-dlp --get-title "${url}"`;

      return new Promise((resolve, reject) => {
        exec(cmd, (error, stdout) => {
          if (error || !stdout) {
            // Fallback to videoId if yt-dlp fails
            resolve(`YouTube Video ${videoId}`);
          } else {
            resolve(stdout.trim());
          }
        });
      });
    } catch {
      // Final fallback
      return `YouTube Video ${videoId}`;
    }
  }
}

const router = Router();

/**
 * POST /api/youtube/download
 * Download YouTube subtitles
 *
 * This endpoint integrates with the existing ytdlpService from the old system.
 * For now, it returns a mock response - the actual implementation should
 * call the existing backend service running on port 8000.
 */
router.post('/download', async (req: Request, res: Response) => {
  try {
    const { url, languages = ['en'] } = req.body as YouTubeDownloadRequest;

    // Validate URL
    if (!url || typeof url !== 'string') {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'URL is required and must be a string',
      });
    }

    // Validate YouTube URL
    if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'URL must be a valid YouTube URL',
      });
    }

    // Call old system's download endpoint
    // Note: old system expects 'videoUrl' (not 'url') and 'preferredLanguage' (not 'languages')
    const oldSystemUrl = `${OLD_SYSTEM_API}/subtitles/download`;
    const response = await fetch(oldSystemUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        videoUrl: url,
        preferredLanguage: languages?.[0], // Use first language as preferred
        includeAutoGenerated: true,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();

    // Transform old system response to new system format
    // Old system returns: { success: true, data: { success: true, video: {...}, subtitles: [...] } }
    const videoData = data.data?.video;
    const videoId = videoData?.id || extractVideoId(url);
    const result: YouTubeDownloadResponse = {
      videoId,
      title: videoData?.title || data.data?.title || 'Unknown Title',
      duration: videoData?.duration || data.data?.duration || 0,
      uploader: videoData?.uploader || data.data?.uploader || '',
      uploadDate: videoData?.upload_date || data.data?.uploadDate || '',
      thumbnailUrl: videoData?.thumbnail || `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`,
      availableSubtitles: videoData?.availableSubtitles?.map((s: any) => s.language) || languages,
      downloadedLanguages: data.data?.subtitles?.map((s: any) => s.language) || languages,
      downloadPath: data.data?.downloadPath || `storage/downloads/${videoId}/`,
    };

    res.json(result);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({
      error: 'Internal Server Error',
      message,
    });
  }
});

/**
 * POST /api/youtube/process
 * Process subtitles and automatically import as asset
 *
 * This endpoint:
 * 1. Calls the Python script to process subtitles (existing functionality)
 * 2. Automatically imports the processed text as a TXT asset with metadata
 * 3. Returns both the processing result and the created asset
 */
router.post('/process', async (req: Request, res: Response) => {
  try {
    const { videoId, language } = req.body as YouTubeProcessRequest;

    // Validate input
    if (!videoId || typeof videoId !== 'string') {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'videoId is required and must be a string',
      });
    }

    if (!language || typeof language !== 'string') {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'language is required and must be a string',
      });
    }

    // Step 1: Call old system's process endpoint
    // Note: old system expects subtitleFile path, not videoId/language
    // Find the actual subtitle file (yt-dlp creates files with video title in filename)
    const subtitleFilePath = await findSubtitleFile(videoId, language);

    if (!subtitleFilePath) {
      return res.status(404).json({
        error: 'Not Found',
        message: `Subtitle file not found for videoId=${videoId}, language=${language}. Please download the subtitles first.`,
      });
    }

    const outputPath = `storage/processed/${videoId}/${language}.txt`;

    const oldSystemUrl = `${OLD_SYSTEM_API}/subtitles/process`;
    const processResponse = await fetch(oldSystemUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        subtitleFile: subtitleFilePath,
        outputPath: outputPath,
        removeTimestamps: true,
        mergeDuplicates: true,
        formatParagraphs: true,
      }),
    });

    if (!processResponse.ok) {
      const errorData = await processResponse.json().catch(() => ({ message: 'Unknown error' }));
      return res.status(processResponse.status).json(errorData);
    }

    const processData = await processResponse.json();

    // Get the real video title from metadata or yt-dlp
    const videoTitle = await getVideoTitle(videoId);

    // Step 2: Import processed file as asset
    const asset = await importService.importFromProcessedFile(
      videoId,
      videoTitle,
      language
    );

    const response: ProcessWithImportResponse = {
      videoId,
      title: videoTitle,
      language,
      processedTextPath: `storage/processed/${videoId}/${language}.txt`,
      importedAssetId: asset.id,
      asset,
    };

    res.json(response);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';

    // Handle specific errors
    if (message.includes('not found')) {
      return res.status(404).json({
        error: 'Not Found',
        message,
      });
    }

    res.status(500).json({
      error: 'Internal Server Error',
      message,
    });
  }
});

/**
 * GET /api/youtube/videos
 * List processed videos
 *
 * Returns a list of videos that have been processed and have assets.
 */
router.get('/videos', async (req: Request, res: Response) => {
  try {
    // TODO: Implement video listing from storage/index
    // For now, return empty array
    res.json({
      videos: [],
      total: 0,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({
      error: 'Internal Server Error',
      message,
    });
  }
});

/**
 * Extract video ID from YouTube URL
 */
function extractVideoId(url: string): string {
  // Handle various YouTube URL formats
  const patterns = [
    /(?:youtube\.com\/watch\?v=)([^&\s]+)/,
    /(?:youtu\.be\/)([^\?\s]+)/,
    /(?:youtube\.com\/embed\/)([^\?\s]+)/,
    /(?:youtube\.com\/v\/)([^\?\s]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }

  throw new Error('Could not extract video ID from URL');
}

export default router;
